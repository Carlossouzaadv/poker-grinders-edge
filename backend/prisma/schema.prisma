// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserType {
  PLAYER
  COACH
}

enum SubscriptionPlan {
  FREE
  PRO
}

enum GameType {
  CASH
  TOURNAMENT
  SIT_AND_GO
}

enum SessionStatus {
  ACTIVE
  COMPLETED
}

enum HandType {
  PREFLOP
  FLOP
  TURN
  RIVER
}

enum CoachStatus {
  PENDING
  APPROVED
  REJECTED
}

enum BookingStatus {
  PENDING
  CONFIRMED
  COMPLETED
  CANCELLED
}

model User {
  id        String           @id @default(cuid())
  email     String           @unique
  password  String
  firstName String
  lastName  String
  phone     String? // Optional phone for future MFA/notifications
  userType  UserType         @default(PLAYER)
  plan      SubscriptionPlan @default(FREE)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Free plan limits
  sessionCount      Int      @default(0)
  dailyTrainerHands Int      @default(0)
  lastTrainerReset  DateTime @default(now())

  // Relations
  sessions            Session[]
  hands               Hand[]
  handHistorySessions HandHistorySession[] // New: hand history analysis sessions

  // Coach specific
  coachProfile CoachProfile?

  // Student bookings
  studentBookings Booking[] @relation("StudentBookings")

  // Refresh tokens
  refreshTokens RefreshToken[]

  @@map("users")
}

model RefreshToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@map("refresh_tokens")
}

model Session {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Basic info
  gameType GameType
  location String? // "PokerStars", "Clube Local", etc.
  status   SessionStatus @default(ACTIVE)

  // Timing
  startTime DateTime  @default(now())
  endTime   DateTime?
  duration  Int? // in minutes

  // Cash Game specific
  buyIn   Decimal? @db.Decimal(10, 2)
  cashOut Decimal? @db.Decimal(10, 2)

  // Tournament specific
  tournamentName String?
  rebuys         Int?     @default(0)
  addOns         Int?     @default(0)
  bounties       Decimal? @db.Decimal(10, 2)
  prize          Decimal? @db.Decimal(10, 2)

  // Calculated fields
  result Decimal? @db.Decimal(10, 2) // profit/loss
  roi    Float? // return on investment %

  // Notes and tags
  notes String?
  tags  String[]

  // Relations
  hands Hand[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("sessions")
}

model Hand {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  sessionId String?
  session   Session? @relation(fields: [sessionId], references: [id], onDelete: SetNull)

  // Hand details
  position   String?
  myCards    String? // "AhKd"
  boardCards String? // "As2h7c"
  stackSize  Int? // in BBs
  potSize    Decimal? @db.Decimal(10, 2)

  // Action taken
  actionTaken String? // "FOLD", "CALL", "RAISE", "ALL_IN"
  betAmount   Decimal? @db.Decimal(10, 2)

  // GTO Analysis
  gtoAction   String? // recommended action
  gtoAnalysis Json? // detailed analysis
  isOptimal   Boolean? // was the action optimal

  // OCR Data
  screenshot String? // path to screenshot
  ocrData    Json? // raw OCR results

  // Training
  isTrainingHand Boolean @default(false)
  difficulty     Int? // 1-5
  scenario       String? // "push_fold", "3bet_spot", etc.

  // Meta
  handType  HandType?
  timestamp DateTime  @default(now())
  notes     String?
  tags      String[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("hands")
}

model CoachProfile {
  id     String @id @default(cuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Verification
  status          CoachStatus @default(PENDING)
  verificationDoc String? // link to proof document
  socialLink      String? // Twitter/LinkedIn
  hendonMobLink   String? // results proof

  // Profile
  bio         String?
  specialties String[] // ["MTT", "CASH", "SNG"]
  languages   String[] // ["PT", "EN"]
  experience  Int? // years

  // Pricing
  hourlyRateUSD Decimal? @db.Decimal(8, 2)
  hourlyRateBRL Decimal? @db.Decimal(8, 2)

  // Stats
  totalHours  Int    @default(0)
  rating      Float? @default(0)
  reviewCount Int    @default(0)

  // Commission tier (15% -> 10% after 50h)
  commissionRate Float @default(0.15)

  // Relations
  bookings Booking[] @relation("CoachBookings")
  reviews  Review[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("coach_profiles")
}

model Booking {
  id String @id @default(cuid())

  // Relations
  studentId String
  student   User         @relation("StudentBookings", fields: [studentId], references: [id], onDelete: Cascade)
  coachId   String
  coach     CoachProfile @relation("CoachBookings", fields: [coachId], references: [id], onDelete: Cascade)

  // Booking details
  status      BookingStatus @default(PENDING)
  scheduledAt DateTime
  duration    Int // minutes

  // Payment
  amount     Decimal @db.Decimal(8, 2)
  currency   String  @default("USD")
  commission Decimal @db.Decimal(8, 2)

  // Session details
  topic String?
  notes String?

  // Completion
  completedAt DateTime?

  // Relations
  review Review?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("bookings")
}

model Review {
  id String @id @default(cuid())

  // Relations
  bookingId String       @unique
  booking   Booking      @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  coachId   String
  coach     CoachProfile @relation(fields: [coachId], references: [id], onDelete: Cascade)

  // Review content
  rating  Int // 1-5 stars
  comment String?

  // Meta
  isPublic Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("reviews")
}

model GTORange {
  id String @id @default(cuid())

  // Scenario identification
  position String
  stackBBs String // "20-30", "50+", etc.
  action   String // "RFI", "3BET", "CALL", etc.

  // Range data
  range     String // "22+,A2s+,K9s+,QTs+,JTs,T9s,98s,87s,76s,65s,54s,ATo+,KQo"
  frequency Float // 0.0 to 1.0

  // Metadata
  scenario String // "6max_cash", "mtt_20bb", etc.
  source   String @default("custom") // "solver", "custom", "imported"

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([position, stackBBs, action, scenario])
  @@map("gto_ranges")
}

// ==============================================================================
// HAND HISTORY ANALYZER - Multi-Hand Session Support
// ==============================================================================

/// Represents a session of hand history analysis (e.g., a tournament or cash game session)
/// containing multiple hands that can be reviewed and navigated by the user
model HandHistorySession {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Session metadata
  name       String // Descriptive name (e.g., "Tournament #123456", "Cash Game 10/20")
  siteFormat String // Poker site format: "PokerStars", "GGPoker", "PartyPoker", "Ignition"
  totalHands Int // Total number of hands in this session

  // Raw data for future reprocessing or debugging
  rawHandHistory String @db.Text // Complete original .txt content

  // Relations
  hands HandHistoryHand[]

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId, createdAt]) // Optimize queries for user's recent sessions
  @@map("hand_history_sessions")
}

/// Represents an individual parsed hand within a hand history session
/// Stores both the raw text and parsed JSON data for efficient querying and display
model HandHistoryHand {
  id        String             @id @default(cuid())
  sessionId String
  session   HandHistorySession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  // Position in session (0-based index for ordering)
  handIndex Int

  // Raw hand text for debugging/reprocessing
  handText String @db.Text

  // Parsed hand data stored as JSON for efficient queries
  // Contains the complete ParsedHand object from the parser
  parsedData Json

  // Timestamps
  createdAt DateTime @default(now())

  @@unique([sessionId, handIndex]) // Ensure no duplicate hands at same position
  @@index([sessionId, handIndex]) // Optimize sequential navigation queries
  @@map("hand_history_hands")
}

// ==============================================================================
// ANONYMIZED HANDS DATABASE - AI Training Data
// ==============================================================================

/// Categorization for cash game rake levels
enum RakeTier {
  MICRO    // $0.01-$0.10 rake
  LOW      // $0.11-$0.50 rake
  MEDIUM   // $0.51-$2.00 rake
  HIGH     // $2.01+ rake
}

/// Categorization for tournament stakes
enum StakesTier {
  MICRO      // $0-$10 buy-in
  LOW        // $11-$50 buy-in
  MEDIUM     // $51-$200 buy-in
  HIGH       // $201-$1000 buy-in
  NOSEBLEED  // $1001+ buy-in
}

/// Stores anonymized poker hands for AI training
/// All player names/IDs are replaced with generic identifiers (Player1, Player2, etc.)
/// Preserves hand structure, actions, and outcomes for ML analysis
model AnonymizedHand {
  id String @id @default(cuid())

  // Original hand metadata (for deduplication)
  handId     String   @unique // Original hand ID from poker site
  site       String // "PokerStars", "GGPoker", "PartyPoker"
  playedAt   DateTime // When the hand was played

  // Categorization for AI training
  gameType GameType // CASH, TOURNAMENT, SIT_AND_GO

  // Cash game specific categorization
  rakeTier  RakeTier? // Only for CASH games
  rakeAmount Decimal? @db.Decimal(10, 4) // Actual rake amount

  // Tournament specific categorization
  stakesTier StakesTier? // Only for TOURNAMENT/SIT_AND_GO
  buyIn      Decimal?     @db.Decimal(10, 2)

  // Game parameters
  smallBlind Decimal @db.Decimal(10, 2)
  bigBlind   Decimal @db.Decimal(10, 2)
  ante       Decimal? @db.Decimal(10, 2)
  maxPlayers Int // 2, 6, 8, 9, etc.

  // Anonymized hand data (JSON format)
  // Structure: {
  //   players: [{position: "BTN", stack: 100, cards: "AhKd"}, ...],
  //   actions: [{player: "Player1", action: "raise", amount: 3}, ...],
  //   board: ["As", "Kh", "Qd", "Jc", "Tc"],
  //   pots: [{amount: 100, winners: ["Player1"]}],
  //   showdown: {...}
  // }
  anonymizedData Json

  // Original hand text (anonymized)
  anonymizedText String @db.Text

  // AI Training metadata
  features Json? // Extracted features for ML (pot odds, SPR, aggression metrics, etc.)
  tags     String[] // ["all-in", "3-bet-pot", "multiway", "short-stack"]

  // Processing metadata
  processedAt DateTime @default(now())

  // Indexes for efficient AI training queries
  @@index([gameType, rakeTier]) // Query cash games by rake tier
  @@index([gameType, stakesTier]) // Query tournaments by stakes tier
  @@index([site, gameType]) // Query by site and game type
  @@index([maxPlayers, gameType]) // Query by table size
  @@index([tags]) // Query by specific scenarios
  @@map("anonymized_hands")
}

/// Tracks anonymization job processing status
/// Ensures idempotent processing and error handling
model AnonymizationJob {
  id String @id @default(cuid())

  // Source reference
  userId              String
  handHistorySessionId String

  // Job status
  status      JobStatus @default(PENDING)
  attempts    Int       @default(0)
  maxAttempts Int       @default(3)

  // Results
  handsProcessed Int @default(0)
  handsSkipped   Int @default(0) // Duplicates or invalid hands
  handsFailed    Int @default(0)

  // Error tracking
  lastError    String?
  lastErrorAt  DateTime?

  // Timing
  startedAt   DateTime?
  completedAt DateTime?
  createdAt   DateTime  @default(now())

  @@index([status, createdAt]) // Query pending/failed jobs
  @@index([userId]) // Query user's jobs
  @@map("anonymization_jobs")
}

enum JobStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
}
